<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>I Trance</title>
<script src="https://js.pusher.com/8.2.0/pusher.min.js"></script>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: black;
  width: 100%;
  height: 100%;
  overflow: hidden;
  -webkit-user-select: none;
  user-select: none;
}
#gate, #control {
  position: fixed;
  inset: 0;
  background: black;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: sans-serif;
  font-size: 2rem;
  z-index: 10;
  cursor: pointer;
  text-align: center;
  padding: 2rem;
}
#gate.waiting {
  font-size: 1.5rem;
  opacity: 0.8;
}
#control {
  flex-direction: column;
  gap: 1rem;
  display: none;
}
#control button {
  padding: 1rem 2rem;
  font-size: 1.5rem;
  background: white;
  color: black;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}
#control button:active {
  transform: scale(0.95);
}
#control button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
#control .status {
  font-size: 1rem;
  opacity: 0.7;
}
#video {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: none;
  z-index: 1;
  background: black;
}
#video:-webkit-full-screen,
#video:fullscreen {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
/* Late comer join button */
#joinBtn {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  color: white;
  display: none;
  align-items: center;
  justify-content: center;
  font-family: sans-serif;
  font-size: 2rem;
  z-index: 20;
  cursor: pointer;
  text-align: center;
  padding: 2rem;
  flex-direction: column;
  gap: 1rem;
}
#joinBtn .sub {
  font-size: 1rem;
  opacity: 0.7;
}
</style>
</head>
<body>
<div id="gate">Tap to enter the trance</div>
<div id="joinBtn">
  <div>Performance in progress</div>
  <div class="sub">Tap to join immediately</div>
</div>
<div id="control">
  <h2>Control Panel</h2>
  <button id="startBtn">Start Performance</button>
  <button id="pauseBtn" disabled>Pause</button>
  <button id="stopBtn" disabled>Stop Performance</button>
  <div class="status" id="status">Ready</div>
</div>
<video id="video" playsinline muted loop></video>
<audio id="audio" src="audio/Get Together.mp3"></audio>

<script>
const params = new URLSearchParams(location.search);
const isControl = params.get("control") === "true";

const gate = document.getElementById("gate");
const joinBtn = document.getElementById("joinBtn");
const control = document.getElementById("control");
const video = document.getElementById("video");
const audio = document.getElementById("audio");
const startBtn = document.getElementById("startBtn");
const pauseBtn = document.getElementById("pauseBtn");
const stopBtn = document.getElementById("stopBtn");
const status = document.getElementById("status");

let armed = false;
let isPerforming = false;
let isPaused = false;
let performanceAlreadyStarted = false; // Track if we're late

const VIDEO_SRC = "audio/itrance.mp4";
const SERVER_URL = "https://light-audience-server.vercel.app";

const pusher = new Pusher('30c6a2b5192e79fdcbdc', { cluster: 'eu' });
const channel = pusher.subscribe('strobe_channel');

async function enterFullscreen(element) {
  try {
    if (element.requestFullscreen) await element.requestFullscreen();
    else if (element.webkitRequestFullscreen) await element.webkitRequestFullscreen();
    else if (element.msRequestFullscreen) await element.msRequestFullscreen();
    else if (element.mozRequestFullScreen) await element.mozRequestFullScreen();
  } catch (err) {
    console.log("Fullscreen failed:", err);
  }
}

function exitFullscreen() {
  if (document.exitFullscreen) document.exitFullscreen();
  else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
  else if (document.msExitFullscreen) document.msExitFullscreen();
  else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
}

// ============= CONTROL PANEL MODE =============
if (isControl) {
  gate.style.display = "none";
  control.style.display = "flex";
  
  status.textContent = "Waking up server...";
  fetch(`${SERVER_URL}/`)
    .then(res => res.json())
    .then(data => { status.textContent = "Ready"; })
    .catch(err => { status.textContent = "Server connection issue"; });

  startBtn.addEventListener("click", async () => {
    try {
      status.textContent = "Starting...";
      const response = await fetch(`${SERVER_URL}/start`, { method: "POST", headers: { "Content-Type": "application/json" }});
      
      if (response.ok) {
        isPerforming = true;
        startBtn.disabled = true;
        pauseBtn.disabled = false;
        stopBtn.disabled = false;
        status.textContent = "Performance LIVE";
        audio.play().catch(err => console.error("Audio error:", err));
      }
    } catch (error) {
      status.textContent = "Error: Cannot connect";
    }
  });

  pauseBtn.addEventListener("click", async () => {
    const endpoint = isPaused ? 'resume' : 'pause';
    try {
      const response = await fetch(`${SERVER_URL}/${endpoint}`, { method: "POST", headers: { "Content-Type": "application/json" }});
      if (response.ok) {
        isPaused = !isPaused;
        pauseBtn.textContent = isPaused ? "Resume" : "Pause";
        status.textContent = isPaused ? "PAUSED" : "Performance LIVE";
        isPaused ? audio.pause() : audio.play();
      }
    } catch (error) {
      status.textContent = "Error";
    }
  });

  stopBtn.addEventListener("click", async () => {
    try {
      const response = await fetch(`${SERVER_URL}/stop`, { method: "POST", headers: { "Content-Type": "application/json" }});
      if (response.ok) {
        isPerforming = false;
        isPaused = false;
        startBtn.disabled = false;
        pauseBtn.disabled = true;
        pauseBtn.textContent = "Pause";
        stopBtn.disabled = true;
        status.textContent = "Stopped";
        audio.pause();
        audio.currentTime = 0;
      }
    } catch (error) {
      status.textContent = "Error stopping";
    }
  });
}

// ============= AUDIENCE MODE =============
else {
  gate.style.display = "flex";
  control.style.display = "none";
  video.src = VIDEO_SRC;

  // Initial tap to check status
  gate.addEventListener("click", async () => {
    gate.textContent = "Checking...";
    gate.classList.add('waiting');
    
    try {
      const response = await fetch(`${SERVER_URL}/status`);
      const state = await response.json();
      
      if (state.isRunning && !state.isPaused) {
        // PERFORMANCE ALREADY RUNNING - Show join button instead of auto-playing
        // This preserves the user gesture for fullscreen
        gate.style.display = "none";
        joinBtn.style.display = "flex";
        performanceAlreadyStarted = true;
      } else {
        // Normal arming flow
        armed = true;
        gate.textContent = "Armed. Waiting for start...";
      }
    } catch (error) {
      console.error("Status check failed:", error);
      // Assume not started, arm anyway
      armed = true;
      gate.textContent = "Armed. Waiting for start...";
    }
  });

  // Late comer joins via explicit tap (preserves user gesture)
  joinBtn.addEventListener("click", () => {
    armed = true;
    startVideo(); // Now this has user gesture context!
  });

  // Listen for START
  channel.bind('START', (data) => {
    if (armed && !performanceAlreadyStarted) {
      // Only auto-start if we weren't a late comer
      // Late comers already have the join button showing
      startVideo();
    }
  });

  channel.bind('PAUSE', (data) => { if (armed) video.pause(); });
  
  channel.bind('RESUME', (data) => { 
    if (armed) {
      video.play().catch(err => console.error("Resume error:", err));
    }
  });

  channel.bind('STOP', (data) => {
    stopVideo();
    gate.style.display = "flex";
    joinBtn.style.display = "none";
    gate.textContent = "Performance ended. Tap to reset.";
    gate.classList.remove('waiting');
    armed = false;
    performanceAlreadyStarted = false;
  });
}

// ============= VIDEO FUNCTIONS =============
async function startVideo() {
  joinBtn.style.display = "none";
  gate.style.display = "none";
  video.style.display = "block";
  video.currentTime = 0;
  
  // Request fullscreen WITH user gesture context
  await enterFullscreen(video);
  
  try {
    await video.play();
  } catch (err) {
    console.error("Play error:", err);
    gate.style.display = "flex";
    gate.textContent = "Tap to retry";
    exitFullscreen();
  }
}

function stopVideo() {
  video.pause();
  video.currentTime = 0;
  video.style.display = "none";
  exitFullscreen();
}

// Handle fullscreen change
document.addEventListener('fullscreenchange', handleFullscreenChange);
document.addEventListener('webkitfullscreenchange', handleFullscreenChange);

function handleFullscreenChange() {
  const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
  if (!isFullscreen && armed && !video.paused) {
    console.log("User exited fullscreen");
  }
}

video.addEventListener('error', (e) => {
  console.error('Video error:', e);
  gate.textContent = "Error loading video";
  gate.style.display = "flex";
  exitFullscreen();
});

audio.addEventListener('error', (e) => {
  if (isControl) status.textContent = "Audio file not found";
});

pusher.connection.bind('connected', () => console.log('Pusher connected'));
pusher.connection.bind('error', (err) => console.error('Pusher error:', err));

// Wake lock for performance
if ('wakeLock' in navigator && !isControl) {
  let wakeLock = null;
  
  video.addEventListener('play', async () => {
    try { wakeLock = await navigator.wakeLock.request('screen'); } 
    catch (err) { console.log('Wake lock failed:', err); }
  });
  
  video.addEventListener('pause', () => {
    if (wakeLock) { wakeLock.release(); wakeLock = null; }
  });
}
</script>
</body>
</html>
